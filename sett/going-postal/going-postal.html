<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <style type="text/css">
      body {
        color: rgb(0, 0, 0);
        background-color: rgb(255, 255, 255);
        font-family: Verdana, sans-serif;
        margin-left: 0.25in;
        margin-right: 0.25in;
      }
      a.career {
        font-weight: bold;
      }
      a:hover {
        color: rgb(0, 0, 255);
        background-color: rgb(255, 253, 160);
      }
      code {
        font-family: "Courier New", monospace;
      }
      div.center {
        text-align: center;
      }
      h1 {
        text-align: center;
      }
      h2 {
        text-align: left;
      }
      h3 {
        text-align: left;
      }
      h4 {
        text-align: left;
      }
      h5 {
        text-align: left;
      }
      hr {
        height: 1px;
        color: rgb(17, 59, 86);
        background-color: transparent;
      }
      kbd {
        font-family: "Courier New", monospace;
      }
      p {
        text-align: justify;
      }
      p.author {
        text-align: center;
      }
      p.footer {
        text-align: justify;
      }
      pre {
        font-family: "Courier New", monospace;
      }
      .educationquicklinks {
        text-align: center;
      }
      .quicklinks {
        text-align: right;
      }
      .red {
        color: rgb(255, 0, 0);
        background-color: rgb(255, 255, 255);
      }
      .green {
        color: rgb(0, 128, 0);
        background-color: rgb(255, 255, 255);
      }
      .blue {
        color: rgb(0, 0, 192);
        background-color: rgb(255, 255, 255);
      }
      .code {
        background-color: #FFFFF0;
        border: dashed black 1px;
        padding-left: 10px;
      }
      .comment {
        color: rgb(128,128,128);
        font-weight: normal;
        font-style: italic;
      }
      .table_header {
        background: pink;
      }
      .table_name {
        font-weight: bold;
        vertical-align: top;
      }
      .table_desc {
        font-weight: normal;
        vertical-align: top;
      }
    </style>
  </head>
  <body>

    <h1>Going Postal with postal.js</h1>
    <p class="author">
      by<br />
      Nicholas Cloud, Software Engineer<br />
      Object Computing, Inc. (OCI)
    </p>

    <h2>JavaScript: a chimera</h2>

    <p>
      One day Brendan Eich forgot to have his morning shot of espresso and, in a decaffeinated stupor, created the JavaScript programming language.  I cannot vouch for the accuracy of this claim but, as this is not a history exposition, we will assume the truth of it.  JavaScript is unique because it is a functional language with classical trappings.  JavaScript code may be organized according to classical conventions primarily through the use of JavaScript constructor functions, or it may be organized according to functional conventions in which individual functions are composed and passed as arguments to other functions.
    </p>

    <p>
      JavaScript objects can message each other via methods, and JavaScript functions can message each other via invocation.  In the dark and distant past, it was common for constructor functions (classes) and functions to live in the global JavaScript scope, which meant that all classes and functions were accessible everywhere.  This was often mitigated by creating classes and functions as public members of a global, named object literal, so that what was once <code>var bar = function () {...};</code> became <code>var Foo = {}; Foo.bar = function () {...};</code>.  This was a much more pleasant situation, but it did nothing to prevent accidental assignment from happening to members of the named object literal, since it was still in the global scope.
    </p>

    <p>
      A far more elegant solution to this problem has come into favor in modern times: the JavaScript module pattern.  Because JavaScript is a functional language, it can leverage closures to give objects returned from a function access to what would otherwise be "private" data and code within the function.  This object then becomes a public API to the code contained within its closure function.  Instead of organizing classes and functions in the global scope, or making them members of a global object, these constructs can be declared inside of a large function closure and only the parts that should be exposed publically can be returned from the closure function invocation, creating a form of encapsulation.  Other code can "message" code within the closure by invoking members on the returned object (or, if the returned object is a function itself, invoking it directly).
    </p>

    <p>
      The module pattern solves the problem of encapsulation, but what we still have is a failure to communicate.  We want modules to message other modules so we can build composable JavaScript applications.  Since modules are large function closures, it makes sense that the closure might accept, as function arguments, the public objects returned from other module closures.  Messages could be sent to, and received from, other modules by interacting with these objects.  This is, in fact, how many JavaScript programs are structured.  There are even libraries such as <a href="http://requirejs.org/" target="_blank" title="require.js">require.js</a> that will resolve and "inject" module dependencies for the developer.  This approach works well for a manageable set of modules, but what happens when modules, like Tribbles, begin to multiply?  What happens when one operation in a given module affects several, or all other modules in an application?  The list of dependencies begins to grow, and every time a new module is introduced, otherwise working code must be changed.
    </p>

    <p>
      This can be avoided. We have the technology. We can build it.
    </p>

    <h2>When going postal <em>is</em> the answer</h2>

    <p>
      It is fortunate for us that a solution to this problem already exists: the message bus.  Gregor Hohpe, in the excellent volume <em>Enterprise Integration Patterns</em>, defines a message bus as "a common command set, and a messaging infrastructure to allow different systems to communicate through a shared set of interfaces."<sup><a href="#fn1">1</a></sup> While JavaScript is hardly identified with "enterprise architecture" (though, oddly enough, it is probably found in nearly every enterprise application in some way or another), the message bus pattern is still an elegant approach to decoupling an application.  <a href="https://github.com/ifandelse/postal.js" target="_blank">postal.js</a> is an in-memory JavaScript message bus, maintained as an open source project by Jim Cowart, "husband, father, architect, developer, tea drinker"<sup><a href="#fn2">2</a></sup>, and international man of mystery. (I may have embellished that last part.)  According to the postal.js README:
      <blockquote cite="https://github.com/ifandelse/postal.js">"Using a local message bus can enable to you de-couple your web application's components in a way not possible with other 'eventing' approaches. In addition, strategically adopting messaging at the 'seams' of your application (e.g. - between modules, at entry/exit points for browser data and storage) can not only help enforce better overall architectural design, but also insulate you from the risks of tightly coupling your application to 3rd party libraries."<sup><a href="#fn3">3</a></sup></blockquote>
    </p>

    <p>
      If you use JavaScript on the client, there is a good chance you also use jQuery or some other DOM abstraction library to handle DOM events and perhaps create your own custom events.  If you are writing JavaScript on the server you probably use node.js and the EventEmitter object to create and handle events as well.  postal.js does not replace these eventing mechanisms, but instead augments an application by providing a common messaging layer between modules that, themselves, leverage these eventing technologies internally.
    </p>

    <p>
      All features of postal.js are accessed via the <code>postal</code> object.  In the browser, the <code>postal</code> object is typically attached to the <code>window</code> object by default.  I explained earlier that, while this is a workable solution, global objects are typically a bad idea for many different reasons.  Instead, wrapping code in closures and passing dependencies to them as function parameters is an excellent way to avoid polluting the global scope.  Fortunately, postal.js ships with two alternate scripts that conform to this pattern:

      <ul>
        <li>an AMD-compatible<sup><a href="#fn4">4</a></sup> script that can be used with AMD loaders like require.js, and</li>
        <li>a node.js module that assigns the <code>postal</code> object to <code>exports</code> which can be accessed by other node.js modules
      </ul>

      Regardless of how your code is organized and your dependencies are managed, however, postal concepts and API calls remain the same.
    </p>

    <h3>Channels and Topics</h3>

    <p>
      When I send a letter to a friend who lives in another city, I specify both the city, state, and street address to which the message will be delivered.  It is entirely possible that a street in another city may share the same name as my friend's street (e.g., Washington Street), but because I have "namespaced" the address with the city in which my friend lives, the post office knows exactly which street is meant.
    </p>

    <p>
      Messages are routed by the message bus according to the <em>channel</em> on which they are published, and the <em>topic</em> the message specifies.  A channel is a logical container for topics.  Channel names must be unique, but topics, like streets in a city, must only be unique for the channel of which they are a part.  When a message is placed on the message bus both a channel and topic are specified, and only handlers which listen for that topic, on that specific channel, will receive that message.
    </p>

    <p>
      To add a message subscription, a channel object is created by invoking the <code>posta.channel()</code> method, supplying one set of the following arguments:
      <ul>
        <li>channel name [string], topic name [string]; <strong>or</strong></li>
        <li>an object with <code>channel</code> [string] and <code>topic</code> [string] properties; <strong>or</strong></li>
        <li>a topic name [string] (the channel name is defaulted to "/", or the "global channel"); <strong>or</strong></li>
        <li>an object with a <code>topic</code> [string] property (the channel name is defaulted to "/", or the "global channel")</li>
      </ul>
    </p>

    <p>
      In the following example I create two channels, <code>vehicle</code> and <code>payment</code>, both of which have a <code>reverse</code> topic.  By calling <code>postal.channel()</code> I obtain subscription definition objects with which I add message handlers to the message bus.  I then publish a message on the vehicle channel, specifying the <code>reverse</code> topic, and the corresponding vehicle subscription callback is invoked.  Notice also that, while I hold a reference to the <code>vehicleChannel</code> object, I can always ask postal for the channel by name/topic elsewhere in code; I need not pass around a channel reference, which is desireable because a message bus is designed to facilitate communication between subsystems that may not even know about each other.
    </p>

    <pre><code>
var vehicleChannel = postal.channel('vehicle', 'reverse');
//or: var vehicleChannel = postal.channel({channel: 'vehicle', topic: 'reverse'});
var paymentChannel = postal.channel('payment', 'reverse');

vehicleChannel.subscribe(function (data) {
  //this callback will be invoked
  console.log('backing up ' + data.qty + ' feet');
});

paymentChannel.subscribe(function (data) {
  //this callback will not be invoked
  console.log('refunding ' + data.qty + ' dollars');
});

postal.channel('vehicle', 'reverse').publish({qty: 3});
    </pre></code>

    <p>
      When a subscription is no longer needed, calling <code>unsubscribe()</code> on the subscription object prevent the message handler from receiving any further messages from the bus.
    </p>

    <h3>Wildcards: <code>#</code> and <code>*</code></h3>

    <p>
      Topics may be refined through dot notation.  It is typically the case that a topic may subsume a number of more specific topics, for which additional channels would be a waste, but nevertheless warrant their own handlers when messages are published on the bus.  For example, <code>order.placed</code>, <code>order.packaged</code>, <code>order.packaged.labeled</code>, <code>order.shipped.ground</code>, and <code>order.shipped.air</code> are all topics related to an order delivery pipeline that many parts of an application would be interested in.
    </p>

    <p>
      If an event handler applies to multiple topic refinements, wildcards can be used to eliminate the need for multiple handlers.  In the following example I set up a handler to respond to any orders that have been shipped, regardless of the shipping method.
    </p>

    <pre><code>
var shippingChannel = posta.channel('fulfillment', 'order.shipped.#');
shippingChannel.subscribe(function (data) {
  //do something with the data
});
    </code></pre>

    <p>
      The "hash" or "pound" symbol can be used as wildcard for <em>one segment of a topic name</em>.  In our fulfillment example, I used the <code>#</code> wildcard to replace the specific <code>ground</code> and <code>air</code> portions of the topic name, since I was only interested in the fact that an order had actually shipped.  The "star" or "asterisk" symbol may be used as a wildcard for any consecutive characters in a topic name, and is not limited to individual segments like the hash symbol.  If I were interested in all order events, for example, I might use the topic <code>order*</code> when requesting a channel.
    </p>

    <h3>Subscriptions</h3>

    <p>The subscription object in postal.js has a number of helpful methods that provide precise control over how and when subscription callbacks are executed.  These API methods may be used individually, or chained together for more complicated callback scenarios.  <em>Note that in most of these examples I am using the global "/" channel by omitting the channel argument from the <code>postal.channel()</code> call.  This omission is a definite indication of laziness.</em></p>

    <h3><code>ignoreDuplicates()</code></h3>

    <p>
      <em>Prevents subscription callbacks from handling duplicate, consecutive topics.</em>
    </p>

    <p>
      It is often desirable to limit the number of times a program can respond to a particular application event.  This is especially important for user interaction scenarios when an accidental double-click could mean the difference between a happy customer with a single credit card charge or an irate customer paying overdraft fees.
    </p>

    <p>
      In the following example, a fictitious shopping cart limits the number of times a customer can add a shirt to her order. The total price only changes when unique items are added to the cart.
    </p>

    <pre><code>
var total = 0;
var c = postal.channel('shop', '#.selected');
c.subscribe(function (item) {
    console.log(item);
  total += item.price;
}).ignoreDuplicates();
 
postal.channel('shop', 'shirt.selected').publish({price: 10});
//duplicate is ignored
postal.channel('shop', 'shirt.selected').publish({price: 10});
postal.channel('shop', 'slacks.selected').publish({price: 15});
postal.channel('shop', 'shoes.selected').publish({price: 20});

//total price is 10 + 15 + 20 = 45
console.log(total);
    </code></pre> 

    <h3><code>disposeAfter(maxCalls)</code></h3>

    <p>
      <em>Automatically unsubscribes a channel after a given number of handler invocations.</em>
    </p>

    <p>
      An application may have an interest in system events, but at some threshold, ceases to care whether those events continue or not.  A channel subscription can be instructed to automatically "dispose" itself (unsubscribe, really) after it has handled a certain number of events.  If events are further published on the channel, the unsubscribed event handler will not be invoked.
    </p>

    <p>
      Below I am interested in capturing a user's top three movies.  Once they have selected three their choice is irreversible, so I instruct the channel to unsubscribe once it has handled three events.
    </p>

    <pre><code>
var favorites = [];
var c = postal.channel('favorite.movies');
c.subscribe(function (m) {
  favorites.push(m);
}).disposeAfter(3);

postal.channel('favorite.movies').publish('Hot Fuzz');
postal.channel('favorite.movies').publish('Blade Runner');
postal.channel('favorite.movies').publish('TRON');
//oh darn, too late--already unsubscribed!
postal.channel('favorite.movies').publish('Star Wars');

//favorite moves are: Hot Fuzz, Blade Runner, and TRON
    </code></pre>

    <h3><code>withConstraint(predicate) / withConstraints(predicates)</code></h3>

    <p>
      <em>Will prevent the subscription handler from executing if a constraint is not met.</em>
    </p>

    <p>
      Although we could add conditional logic in the body of an event handler, postal provides methods whereby we can specify one or more conditions that must be met in order for the event handler to be executed when a publish occurs on the channel.  This keeps the event handler clean, unpolluted with criteria logic that is related to the behavior of the subscription.
    </p>

    <p>
      If you have seen <em>Back to the Future</em> you know that the one constant of time travel is that a time machine must reach 88 MPH to traverse the ages.  Undoubtedly Doc Brown's code looked something like this:
    </p>

    <pre><code>
var speed = 88;

postal.channel('vehicle.accelerated').subscribe(function (passenger) {
  timeTravel(passenger);
}).withConstraint(function () {
  return speed === 88;
});

postal.channel('vehicle.accelerated').publish('Marty');
    </code></pre>

    <h3><code>withContext(context)</code></h3>

    <p>
      <em>Determines the value of <code>this</code> within a subscription callback.</em>
    </p>

    <p>
      The JavaScript <code>this</code> keyword is schizophrenic.  Its identity changes depending on the scope in which it is used, and it is often not at all predictable.  A free-standing function is attached automatically to the global object (<code>window</code> in the browser), so the value of <code>this</code> within that function is the global object.  A function that is assigned to an object property (a method) will reference that object when <code>this</code> is used. The <code>Function</code> object prototype also has both <code>call()</code> and <code>apply()</code> methods which allow the value of <code>this</code> to be set when a function is invoked.
    </p>

    <p>
      Because postal subscriptions use anonymous functions as callbacks, the value of <code>this</code> within the callback is, by default, the global object.  The postal API allows this to be manipulated, however, so that when a callback is invoked, the <code>this</code> variable may be set deterministically.  In the example below I want to modify a DOM element when my coffee is ready, and because I am lazy, I use <code>withContext()</code> to capture a reference to my "mug" DOM element, which will be the value of <code>this</code> within my callback.
    </p>

    <p>
      It is also important to note that postal caches the object passed into <code>withContext()</code>, so in this case the DOM is traversed only once for the "mug" element.  All callbacks will have a reference to the exact same object.
    </p>

    <pre><code>
var c = postal.channel('coffee.ready');

c.subscribe(function (data) {
  //this === window
});

c.subscribe(function (data) {
  //this === $('#mug')
}).withContext(
    (function () { 
        console.log('this will happen once');
        return $('#mug');
    }())
);

postal.channel('coffee.ready').publish({});
postal.channel('coffee.ready').publish({});
postal.channel('coffee.ready').publish({});
    </code></pre>

    <h3><code>withDebounce(milliseconds)</code></h3>

    <p>
      <em>Delays execution of the callback for a given number of milliseconds after the last time the callback would have been invoked.</em>
    </p>

    <p>
      My wife often says many things to me over a very short period of time.  She is very good at communicating, but I am not as good at listening.  I tend to remember the last thing she tells me but everything prior to that evades my short term memory.  This is because, by default, I have <code>debounce</code> enabled.
    </p>

    <p>
      In postal, <code>debounce()</code> is used to delay the execution of a callback by a specific period of time <em>after the last time the callback would have been invoked had the delay not been in place.</em>  When a stream of messages are published to postal in rapid succession, often a handler is only interested in the last of the messages, which represents the final state of some operation.  When <code>debounce()</code> is called on a subscription object, postal will delay the execution of the subscription callback by the duration specified.  If postal receives a message for the handler before this timeframe has elapsed, it resets the timer to zero and begins to wait again.  If the time elapses with no further interruption, the callback is invoked.
    </p>

    <p>
      In the following example I am listening for the <code>window.resize</code> event, which is a notoriously noisy.  The event fires often as the user drags the edge of the browser, but I am really only interested in the final size of the viewport when the resizing has been completed.  I use <code>debounce()</code> to delay the invocation of my callback for exactly one second each time a resize message is published to postal.
    </p>

    <pre><code>
var c = postal.channel('resize');

c.subscribe(function (dim) {
  $('#movie').height(dim.h / 2)
    .width(dim.w / 2);
}).withDebounce(1000);

$(window).resize(function () {
  postal.channel('resize').publish({
    h: this.innerHeight,
    w: this.innerWidth
  });
});
    </code></pre>

    <h3><code>withDelay(milliseconds)</code></h3>

    <p>
      <em>Delays the subscription callback execution for a given number of milliseconds.</em>
    </p>

    <p>
      A delay is similar to a debounce in that they both defer the invocation of a callback until some future point in time.  Unlike a debounce, a delay does not discard all publishes messages except the last.  A delayed callback will still react to all messages published to its channel during the delay period, but it defers <em>all</em> invocations.
    </p>

    <p>
      Waking up in the morning can be a difficult task, so I can delay the inevitable by hitting the snooze button on my alarm clock.  In the example below I am only publishing one "wakeup.alarm" message to the bus, but if I had published more, the callback would execute for each message published.
    </p>

    <pre><code>
var c = postal.channel('wakeup.alarm');

//going to snooze for 30 mins.
var snoozeDuration = (30 * 60 * 1000);

c.subscribe(function (data) {
  
  //make sure this lazy ass gets out of bed!
  alarm.buzz({volume: data.volume});

}).withDelay(snoozeDuration);

postal.channel('wakeup.alarm').publish({volume: 'annoying'});
    </code></pre>

    <h3><code>withPriority(priority)</code></h3>

    <p>
      <em>Associates a subscription callback with an arbitrary priority number; higher priority callbacks are triggered first.</em>
    </p>

    <p>
      Typically the order in which messages are handled on a message bus is irrelevant, but occasionally it is helpful to specify the order in which handlers react to published messages.  The subscription object provides a <code>withPriority()</code> method that accepts a number indicating the relative priority its handler should receive.  A higher number will take precedence over a lower number.
    </p>

    <p>
      I've created to handlers that respond to a stock event messages--one handler represents stock holders, the other, inside traders.  Even though the stock holder subscription is created first, its lower priority number means that it will be executed after the inside trader handler.
    </p>

    <pre><code>
var c = postal.channel('stock.event');

var stockholder = function (data) {
  console.log('Stockholder knows!');
};

var insider = function (data) {
  //will always know first!
  console.log('Insider knows!');
};

c.subscribe(stockholder).withPriority(75);
c.subscribe(insider).withPriority(100);

postal.channel('stock.event').publish({action: 'sell!'});
    </code></pre>

    <h3><code>withThrottle(milliseconds)</code></h3>

    <p>
      <em>Prevents a subscription callback from being invoked more than once in a given time frame (in milliseconds).</em>
    </p>

    <p>
      A throttled subscription will invoke its handler once, then wait for a specified period of time before invoking it again, regardless of the number of messages that are published to that channel during that time.  Once the throttle period has elapsed, the handler may then respond to another message, but will ignore subsequent messages until the throttle period has, again, elapsed.  This allows a subscription to effectively "ignore" a steady stream of messages, preferring to respond to individual messages, at timed intervals, instead.  Like <code>debounce()</code> and <code>withDelay()</code>, this API method is designed to mitigate the demand high message traffic.
    </p>

    <p>
      GPS tracking is a good source of constant, streaming data. In the example that follows I simulate the movement of a high-speed with a recursive function that increments its position on a linear path.  Each time the movement function executes--every 0.5 seconds--it publishes an event to the bus.  The subscription handler has a throttle of two seconds because the movement data is being published too quickly.
    </p>

    <pre><code>
var c = postal.channel('dhs.track.movement');

c.subscribe(function (pos) {
  console.log('Moved to ' + pos);
}).withThrottle(2000);

(function move (timesMoved) {
  if (timesMoved === 50) return;
  postal.channel('dhs.track.movement').publish(timesMoved);
  setTimeout(function () {
    move(timesMoved + 1);
  }, 500);
}(0));
    </code></pre>

    <h3><code>defer()</code></h3>

    <p>
      <em>Prevents the callback from executing until the current execution stack is cleared. Useful for long computations that could make the UI non-responsive.</em>
    </p>

    <p>
      One key principle of user interface design is that the user should not be kept waiting.  A responsive UI is a friendly UI.  Since JavaScript is executed on a single thread in the browser, it must use clever tricks to simulate parallel operations.  Using a subscription's <code>defer()</code> method effectively short-circuits these tricks, and forces the runtime to finish what it's doing before the event handler executes its code.  This allows the UI to stay responsive for as long as possible before performing resource-intensive operations.
    </p>

    <pre><code>
var largeDataSet = {}; //lots of data in here

var c = postal.channel('schedule', 'query');
c.subscribe(function (query) {
  var item, results = [];
  for (item in largeDataSet) {
    if (!largeDataSet.hasOwnProperty(item)) continue;
    if (query.matches(item)) {
      results.push(item);
    }
  }
  postal.channel('schedule', 'filter').publish(results);
}).defer();

//elsewhere...
$('input[type="checkbox"]').change(function () {
  var checkbox = this;
  var query = {
    matches: function (item) {
      return item.title === checkbox.value;
    }
  };
  postal.channel('schedule', 'query').publish(query);
});
    </code></pre>


    <h2>Putting it all together</h2>

    <p>
      So far we've seen what postal.js can do, but not how it might actually be used.  To illustrate how an application using modules might take advantage of the postal message bus, I have created a demo application that is openly available in my <a href="https://github.com/nicholascloud/writing/tree/master/sett/going-postal/demo" target="_blank">Github repository</a>.  While duplicating the project code in this article would be prohibitive, I will give you an overview of the project (with pictures!) and explain how the code is organized, and how it leverages postal.js to manage user interactions on the page.
    </p>

    <p>
      My demo project is called <em>LEARNyou</em>.  It is a small, fictitious application that is designed to pair people with certain skills with people who want to learn those skills.  If I want to learn how to replace kitchen cabinets, I can browse to <em>LEARNyou</em> and search for someone in my city that's willing to teach me how to do it (for a fee, of course).  It's like a very limited Craigslist for knowledge and skills.
    </p>

    <p>
      The initial set of use cases for this application is very small:
      <ul>
        <li>users can pick a skill category to see people offering to teach skills subsumed under that category</li>
        <li>users can search for a particular skill and see people offering to teach that skill</li>
        <li>users can view details about someone who is willing to teach a skill</li>
      </ul>
    </p>

    <p>
      The application is a single page, divided into several functional areas that the user can interact with.  At the top is a "tag cloud" that displays all skill categories.  At the bottom is a list of people within a category, and the services that they are offering.  When a user clicks on a particular category, the offers below the tag cloud change.  A the bottom of the page is a search bar, in which the user can enter queries that will filter both the tag cloud and the available offers if matches are found.
    </p>

    <figure style="display:block; margin:auto; padding:2%; width:500px;">
      <img src="img/learnyou01.png" alt="LEARNyou home screen" />
      <figcaption>LEARNyou</figcaption>
    </figure>

    <p>
      The application's JavaScript code has been separated into modules that correspond to the functional areas of the page, as well as some "plumbing" modules that handle lower-level tasks.  All modules are located under the <code>js/</code> directory and are written for require.js.  (Understanding how require.js works is not necessary for understanding the structure of the application.  All you need to know is that require.js loads and passes dependencies into modules for you.  In this case, I am mainly using require.js to pass the jQuery and postal objects to my modules).

      Below is a list of modules, along with what messages they subscribe and listen to on the message bus.
    </p>

    <h3><code>home.js</code></h3>
    
    <p>
      <em>Configures require.js.</em>
    </p>
    
    <ul>
      <li>when all modules have been loaded, publishes a "ready" message to the message bus</li>
    </ul>

    <h3><code>search.js</code></h3>
    
    <p>
      <em>Queries the data store when the user performs a search.</em>
    </p>
    
    <ul>
      <li>publishes a "search.categories" message when categories on the page should change to match search results</li>
      <li>publishes a "search.offers" message when offers on the page should change to match search results</li>
    </ul>

    <figure style="display:block; margin:auto; padding:2%; width:500px;">
      <img src="img/learnyou03.png" alt="Performing a search highlights applicable categories and changes the visible offers" />
      <figcaption>Performing a search highlights applicable categories and changes the visible offers</figcaption>
    </figure>

    <h3><code>tagCloud.js</code></h3>
    
    <p>
      <em>Manages user interaction with the tag cloud at the top of the page.</em>
    </p>
    
    <ul>
      <li>subscribes to a message which is generated when the whole page has loaded and highlights an initial category for the user</li>
      <li>subscribes to a "search.categories" message generated by the search module; highlight categories that match search results</li>
      <li>publishes a "categories.changed" message whenever one or more category has been selected</li>
      <li>subscribes to a "categories.changed" message generated by <em>itself</em>; highlight the categories that have been selected</li>
    </ul>

    <figure style="display:block; margin:auto; padding:2%; width:500px;">
      <img src="img/learnyou02.png" alt="Choosing a different category highlights that category and changes the visible offers" />
      <figcaption>Choosing a different category highlights that category and changes the visible offers</figcaption>
    </figure>
    
    <h3><code>offers.js</code></h3>

    <p>
      <em>Manages user interaction with the list of offers below the tag cloud and loads and refreshes offers when the user selects a category from the tag cloud or when the user performs a search.</em>
    </p>
        
    <ul>
      <li>subscribes to a "categories.changed" message generated by the tag cloud module which indicates that a new category has been selected; offers are then refreshed based on the new category</li>
      <li>subscribes to a "search.offers" message generated by the search module; loads offers that match search results</li>
      <li>expands an offer's details when it is clicked; no message is published for this event</li>
    </ul>

    <figure style="display:block; margin:auto; padding:2%; width:500px;">
      <img src="img/learnyou04b.png" alt="Clicking on an offer reveals offer details" />
      <figcaption>Clicking on an offer reveals offer details</figcaption>
    </figure>

    <h3>Utility scripts</h3>

    <p>The utility scripts do not subscribe to messages from, or publish to, the message bus, but provide plumbing for the rest of the application.</p>

    <ul>
      <li><code>data.js</code> - a data access module for hard-coded demo data.</li>
      <li><code>jqueryext.js</code> - some simple jQuery extensions.</li>
      <li><code>querystring.js</code> - a small module that parses query string parameters.</li>
      <li><code>template.js</code> - a small module that builds DOM elements using jQuery.</li>
    </ul>

    <p>
      Even though <em>LEARNyou</em> is a simple demo project, it still makes good use of the module pattern to encapsulate code, and uses the postal message bus to allow these modules to communicate without having to know about each other.  Each module subscribes to and publishes messages as needed.
    </p>

    <h2>Conclusion</h2>

    <p>
      There are two important ideas that are common to applications developed on all platforms, in all languages, and in all paradigms.
    </p>

    <p>
      The first idea is that code should, to some extent, be isolated from other code.  In classical languages encapsulation is accomplished by access modifiers on classes and members; in functional languages this is accomplished with closures; and in procedural languages this is accomplished by the religious inclusion of underscores in structure member names, a ritual which reminds other developers to behave themselves and pretend that said members are, in fact, private.
    </p>

    <p>
      The second idea is that these isolated pieces of code, whilst hiding their implementations from prying eyes, nevertheless must communicate with each other, much like those awkward conversations we all have every year at Thanksgiving.  Regardless of how code is organized, if it cannot communicate or message other code, our programs would be severely restricted and code reuse would cease to be possible.
    </p>

    <p>
      On the surface, both of these ideas might appear to be antithetical.  How can hidden or encapsulated code, about which external code must necessarily be agnostic, communicate with the very code it hides from?  By delegating communication to a neutral third party, who acts as a message broker on behalf of all units of code involved.  For JavaScript modules, postal.js excels at this role.  The postal.js API is simple and terse, and sports a powerful set of features that give a developer significant control over how and when messages are handled.  Channels and topics are a convenient way for applications to organize messages, and wildcard subscriptions eliminate the need for overly-granular callbacks.
    </p>

    <p>
      The power of postal.js makes it a library fit for every JavaScript developer's toolkit.
    </p>

    <h2>Footnotes</h2>

    <ol>
      <li><a name="fn1" />Hohpe, Gregor. <em>Enterprise Integration Patterns</em>. 2004 Pearson Education, Inc. p. 139.</li>
      <li><a name="fn2" />Cowart, Jim. "About". <a href="http://freshbrewedcode.com/jimcowart/about/" target="_blank">Fresh Brewed Code</a>. n.d. web 13 May 2012.</li>
      <li><a name="fn3" />Cowart, Jim. "README". <a href="https://github.com/ifandelse/postal.js" target="_blank">ifandelse/postal.js</a>. Github.  23 April 2012.</li>
      <li><a name="fn4" />cmosher01. "AMD". <a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank">amdjs/amdjs-api</a>. Github.</li>
    </ol>

    <h2>References</h2>
    <ul>
      <li><a href="https://github.com/ifandelse/postal.js" title="postal.js Github repository">postal.js Github repository</a></li>
      <li><a href="http://jsfiddle.net/ifandelse/FdFM3/" title="postal.js jsFiddle examples">postal.js jsFiddle examples</a></li>
      <li><a href="http://www.twitter.com/ifandelse" title="Jim Cowart (@ifandelse) on Twitter">Jim Cowart (@ifandelse) on Twitter</a></li>
      <li><a href="http://freshbrewedcode.com/jimcowart/2011/12/05/client-side-messaging-with-postal-js-part-1/" title="Client-side Messaging in JavaScript -- Part 1 (Postal.js)">Client-side Messaging in JavaScript -- Part 1 (Postal.js)</a></li>
      <li><a href="http://freshbrewedcode.com/jimcowart/2012/02/02/client-side-messaging-in-javascript-part-2-postal-js/" title="Client-side Messaging in JavaScript -- Part 2 (Postal.js)">Client-side Messaging in JavaScript -- Part 2 (Postal.js)</a></li>
      <li><a href="http://freshbrewedcode.com/jimcowart/2012/03/19/client-side-messaging-in-javascript-part-3-anti-patterns/" title="Client-side messaging in JavaScript -- Part 3 (anti-patterns)">Client-side messaging in JavaScript -- Part 3 (anti-patterns)</a></li>
    </ul>

  </body>
</html>